/*
Лабораторная работа 3
Задание 3
Программа сортировки методом быстрой сортировки (Quick Sort)
*/

#include <iostream>
#include <windows.h>

using namespace std;

// Функция для обмена значений двух элементов массива
void swap(int arr[], int pos1, int pos2) {
    int temp;
    temp = arr[pos1];
    arr[pos1] = arr[pos2];
    arr[pos2] = temp;
}

// Функция разделения (partition)
// Выбирает опорный элемент (pivot) и переупорядочивает массив так,
// что все элементы меньше или равные pivot оказываются слева от него,
// а все элементы больше pivot - справа.
// Возвращает индекс, на котором оказался pivot после перестановки.
int partition(int arr[], int low, int high, int pivot) {
    int i = low;
    int j = low;
    while (i <= high) {
        // В данной реализации pivot передается как значение, но логика partition
        // обычно подразумевает, что pivot находится в массиве (например, arr[high]).
        // Здесь мы сравниваем текущий элемент с pivot.
        // Если элемент больше pivot, просто идем дальше (он останется справа от границы j).
        if (arr[i] > pivot) {
            i++;
        } else {
            // Если элемент меньше или равен pivot, меняем его с элементом на границе j
            // и сдвигаем границу j вправо.
            swap(arr, i, j);
            i++;
            j++;
        }
    }
    // j указывает на первый элемент, который БОЛЬШЕ pivot (или на high+1).
    // Поэтому последний элемент, который <= pivot, находится по индексу j-1.
    return j - 1;
}

// Рекурсивная функция быстрой сортировки
// low - начальный индекс подмассива
// high - конечный индекс подмассива
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Выбираем опорный элемент (в данном случае последний элемент подмассива)
        int pivot = arr[high];

        // Получаем индекс опорного элемента после разделения
        int pos = partition(arr, low, high, pivot);

        // Рекурсивно сортируем левую часть (до опорного элемента)
        // Обратите внимание: pos - это индекс элемента <= pivot.
        // В классической схеме Lomuto pivot ставится на свое место, и рекурсия идет для (low, pos-1) и (pos+1, high).
        // В данной реализации partition возвращает позицию последнего элемента <= pivot.
        // Так как pivot был arr[high], он попал в позицию pos.
        // Значит, слева от pos (включительно) элементы <= pivot, справа - больше.
        // Но так как pivot сам участвовал в swap и оказался на позиции pos,
        // то pos - это его окончательное место.

        quickSort(arr, low, pos - 1);
        quickSort(arr, pos + 1, high);
    }
}

int main() {
    SetConsoleOutputCP(CP_UTF8); // Для нормального отображения русского языка в консоли

    int arr[] = {-2, 5, -8, 1, -10, 2, 11, 0, 4, -9};
    int arrLength = sizeof(arr) / sizeof(int);

    cout << "Исходный массив: ";
    for (int i = 0; i < arrLength; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    quickSort(arr, 0, arrLength - 1);

    cout << "Массив в отсортированном виде: ";
    for (int i = 0; i < arrLength; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
