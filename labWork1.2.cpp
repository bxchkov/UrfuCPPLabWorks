/*
Лабораторная работа 1
Задание 2
Программа, иллюстрирующая разные операции с указателями
*/

// Макрос PR для удобного вывода информации об указателе:
// x - значение указателя (адрес, на который он указывает)
// *x - значение, хранящееся по этому адресу (разыменование)
// &x - адрес самой переменной-указателя в памяти
// %u используется для вывода беззнаковых целых чисел (адресов), %d - для знаковых целых (значений int)
// Примечание: для *x используется %d, что корректно для int, но для char и double вывод может быть некорректным (будет интерпретироваться как int).
// В данном учебном примере это допустимо для демонстрации адресов, но в реальном коде стоит учитывать типы.
#define PR(x) printf("x=%u, *x=%d, &x=%u\n", x, *x, &x)

#include <iostream>
#include <cstdio> // Для printf

int main() {
    // --- Работа с массивом целых чисел (int) ---
    // int обычно занимает 4 байта
    int mas[] = {100, 200, 300};
    int *ptr1 = mas;      // ptr1 указывает на первый элемент массива (mas[0] = 100)
    int *ptr2 = &mas[2];  // ptr2 указывает на третий элемент массива (mas[2] = 300)

    PR(ptr1); // Вывод информации о ptr1

    ptr1++;   // Инкремент указателя. Адрес увеличится на sizeof(int) (обычно 4 байта). Теперь указывает на mas[1] = 200.
    PR(ptr1); // Вывод обновленного ptr1

    PR(ptr2); // Вывод информации о ptr2

    ++ptr2;   // Инкремент ptr2. Теперь указывает на память сразу за массивом (опасно разыменовывать, но адрес валиден).

    // Вычитание указателей: результат - количество элементов типа int между адресами.
    // ptr2 указывает за mas[2], ptr1 указывает на mas[1]. Разница в индексах.
    printf("ptr2-ptr1=%u\n\n", ptr2 - ptr1);


    // --- Работа с массивом символов (char) ---
    // char занимает 1 байт
    char str[] = "Hello";
    char *ptr3 = str;     // ptr3 указывает на 'H'
    char *ptr4 = &str[4]; // ptr4 указывает на 'o'

    // Внимание: макрос PR использует %d для *x. Для char это выведет ASCII-код символа.
    PR(ptr3);

    ptr3++;   // Адрес увеличится на sizeof(char) (1 байт). Теперь указывает на 'e'.
    PR(ptr3);

    PR(ptr4);

    ++ptr4;   // Указывает на нуль-терминатор '\0' (конец строки)

    // Разница указателей в элементах char (байтах)
    printf("ptr4-ptr3=%u\n\n", ptr4 - ptr3);


    // --- Работа с массивом вещественных чисел (double) ---
    // double обычно занимает 8 байт
    double arr[] = {1.2, 3.4, 5.6};
    double *ptr5 = arr;     // ptr5 указывает на 1.2
    double *ptr6 = &arr[2]; // ptr6 указывает на 5.6

    // Внимание: макрос PR использует %d для *x. Для double это выведет мусор или неверное значение,
    // так как printf будет читать 4 байта как int, а там лежит double (8 байт).
    // Но для демонстрации изменения адресов (x=%u) это работает.
    PR(ptr5);

    ptr5++;   // Адрес увеличится на sizeof(double) (обычно 8 байт). Теперь указывает на 3.4.
    PR(ptr5);

    PR(ptr6);

    ++ptr6;   // Указывает за пределы массива

    // Разница указателей в элементах double
    printf("ptr6-ptr5=%u\n\n", ptr6 - ptr5);

    return 0;
}
